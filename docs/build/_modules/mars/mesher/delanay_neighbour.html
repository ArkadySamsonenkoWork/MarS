

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mars.mesher.delanay_neighbour &mdash; MarS 2026.01.11 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7e9183e1"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MarS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/base_spin_system.html">Base Spin System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/sample.html">Sample Representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/spectrum_constraction.html">EPR Spectrum Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/fitting_tutorial.html">Fitting Spectroscopic Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/interactions/index.html">Interactions in MarS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/populators/index.html">Population Computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/context/index.html">Relaxation Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/spectra_creators/index.html">Spectra Creators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/intensity_calculators/index.html">Transition Intensity Calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contents/meshers/index.html">Meshing Strategies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/mars.html">mars package</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_1.html">Continuous-Wave EPR Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_2.html">Polarized Radiation EPR Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_3.html">Fitting Procedures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_4.html">Advance Fitting Procedures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_5.html">Spectra Polarization and Time Resolved</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_6.html">Multi-System Kinetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/example_7.html">Time-Resolved Fitting Procedures</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/ArkadySamsonenkoWork/MarS.git"> GitHub Repository</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MarS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mars.mesher.delanay_neighbour</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mars.mesher.delanay_neighbour</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">tp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">sph_harm</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nn</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">pairwise_distances</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.general_mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseMeshPowder</span>


<div class="viewcode-block" id="BoundaryHandler">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BoundaryHandler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BoundaryHandler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handles boundary condition logic.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="BoundaryHandler.get_boundary">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BoundaryHandler.get_boundary">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_boundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">init_indexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">is_start</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s2">&quot;reflection&quot;</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_start</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_start</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid phi boundary condition.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">init_indexes</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="ThetaLine">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.ThetaLine">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ThetaLine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a line of constant theta with variable phi sampling.</span>

<span class="sd">    Used during mesh construction to generate vertices with adaptive density</span>
<span class="sd">    based on spherical geometry requirements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ThetaLine.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.ThetaLine.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">last_point</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize theta line with sampling parameters.</span>

<span class="sd">        :param theta: Polar angle in radians [0, pi]</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param points: Number of latent sampling points along phi</span>
<span class="sd">        :type points: int</span>
<span class="sd">        :param phi_limits: (phi_min, phi_max) bounds in radians</span>
<span class="sd">        :type phi_limits: tuple[float, float]</span>
<span class="sd">        :param last_point: Whether to include the endpoint at phi_max</span>
<span class="sd">        :type last_point: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span> <span class="o">=</span> <span class="n">phi_limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_point</span> <span class="o">=</span> <span class="n">last_point</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_visible_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute number of visible points after boundary handling.</span>

<span class="sd">        :return: Number of points to actually generate</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_point</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">-</span> <span class="mi">1</span>

<div class="viewcode-block" id="ThetaLine.phi_theta">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.ThetaLine.phi_theta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">phi_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate (phi, theta) coordinate pairs for this theta line.</span>

<span class="sd">        :return: List of (phi, theta) tuples in radians</span>
<span class="sd">        :rtype: list[tuple[float, float]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="n">delta_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_point</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">point</span> <span class="o">*</span> <span class="n">delta_phi</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span>
                    <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">point</span> <span class="o">*</span> <span class="n">delta_phi</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span>
                    <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latent_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span></div>
</div>



<div class="viewcode-block" id="BaseInterpolator">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BaseInterpolator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseInterpolator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for spherical mesh interpolators.</span>

<span class="sd">    Defines the interface for interpolating scalar fields from a coarse base mesh</span>
<span class="sd">    to a finer target mesh on the unit sphere. All concrete interpolators must</span>
<span class="sd">    implement the forward pass and provide a transformation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BaseInterpolator.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BaseInterpolator.__init__">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_vertices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">extended_vertices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the interpolator with source and target vertex sets.</span>

<span class="sd">        :param init_vertices: Base mesh vertices as (phi, theta) pairs.</span>
<span class="sd">            Shape (N, 2) with phi ∈ [0, 2π), theta ∈ [0, π/2].</span>
<span class="sd">        :type init_vertices: list[tuple[float, float]] | np.ndarray</span>
<span class="sd">        :param extended_vertices: Target vertices for interpolation.</span>
<span class="sd">            Shape (M, 2) with phi ∈ [0, 2π), theta ∈ [0, π/2].</span>
<span class="sd">        :type extended_vertices: list[tuple[float, float]] | np.ndarray</span>
<span class="sd">        :param device: Computation device for storing tensors</span>
<span class="sd">        :type device: torch.device</span>
<span class="sd">        :param dtype: Floating point precision for computations</span>
<span class="sd">        :type dtype: torch.dtype</span>
<span class="sd">        :param args: Additional positional arguments for subclasses</span>
<span class="sd">        :param kwargs: Additional keyword arguments for subclasses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert spherical coordinates (phi, theta) to Cartesian unit vectors.</span>

<span class="sd">        Uses physics convention:</span>
<span class="sd">          - phi: azimuthal angle in xy-plane from x-axis [0, 2π)</span>
<span class="sd">          - theta: polar angle from positive z-axis [0, π]</span>

<span class="sd">        :param vertices: Array of shape (K, 2) containing (phi, theta) in radians</span>
<span class="sd">        :type vertices: np.ndarray</span>
<span class="sd">        :return: Normalized Cartesian vectors of shape (K, 3) on unit sphere</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_lat_long</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert (phi, theta) spherical coordinates to latitude-longitude format.</span>

<span class="sd">        Transforms:</span>
<span class="sd">          - longitude = phi</span>
<span class="sd">          - latitude = π/2 - theta</span>

<span class="sd">        :param vertices: List of (phi, theta) pairs in radians</span>
<span class="sd">        :type vertices: list[tuple[float, float]]</span>
<span class="sd">        :return: Array of shape (N, 2) with [latitude, longitude] in radians</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

<div class="viewcode-block" id="BaseInterpolator.forward">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BaseInterpolator.forward">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_values</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate values at extended points using RBF interpolation.</span>

<span class="sd">        :param f_values: Tensor of shape (..., N), where N = number of base vertices.</span>
<span class="sd">        :return: Interpolated values of shape (..., M), where M = number of extended vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the linear transformation matrix for interpolation.</span>

<span class="sd">        The matrix W satisfies: f_extended = f_base @ W</span>
<span class="sd">        where W has shape (N, M), N = base vertices, M = extended vertices.</span>

<span class="sd">        :return: Transformation matrix of shape (N, M)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="RBFInterpolator">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.RBFInterpolator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RBFInterpolator</span><span class="p">(</span><span class="n">BaseInterpolator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Radial Basis Function interpolator for spherical mesh refinement with symmetry awareness.</span>

<span class="sd">    Performs interpolation from a coarse base mesh to a finer extended mesh on the unit sphere</span>
<span class="sd">    using geodesic (great-circle) distances and robust regularization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="RBFInterpolator.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.RBFInterpolator.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">init_vertices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">extended_vertices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">kernel</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;thin_plate&quot;</span><span class="p">,</span>
                 <span class="n">regularization</span><span class="o">=</span><span class="s2">&quot;spherical&quot;</span><span class="p">,</span>
                 <span class="n">jitter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
                 <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize RBF interpolator with spherical geometry.</span>

<span class="sd">        :param init_vertices: Base mesh vertices as (phi, theta) pairs on upper hemisphere.</span>
<span class="sd">            Shape (N, 2) with phi ∈ [0, 2π), theta ∈ [0, π/2].</span>
<span class="sd">        :type init_vertices: list[tuple[float, float]] | np.ndarray</span>
<span class="sd">        :param extended_vertices: Target vertices for interpolation.</span>
<span class="sd">            Shape (M, 2). with phi ∈ [0, 2π), theta ∈ [0, π/2].</span>

<span class="sd">        :type extended_vertices: list[tuple[float, float]] | np.ndarray</span>
<span class="sd">        :param kernel: RBF kernel type. Default is  &quot;thin_plate&quot;. It supporst also</span>
<span class="sd">            &quot;gaussian&quot;, &quot;multiquadric&quot;, &quot;inverse_multiquadric&quot;, &quot;linear&quot;, &quot;cubic&quot;.</span>
<span class="sd">        :type kernel: str</span>

<span class="sd">        :param regularization: Regularization method. Options: &quot;spherical&quot;, &quot;tikhonov&quot;</span>
<span class="sd">        :type regularization: str</span>
<span class="sd">        :param jitter: Small value is multiplied on regularization</span>
<span class="sd">        :type jitter: float</span>

<span class="sd">        :param epsilon: Shape parameter controlling kernel width. Larger values → smoother</span>
<span class="sd">            interpolation; smaller values → tighter fit (risk of overfitting/instability).</span>
<span class="sd">            For &quot;thin_plate&quot;, typically set to 1.0 (scale-invariant).</span>
<span class="sd">        :type epsilon: float</span>
<span class="sd">        :param device: Computation device for transform matrix storage</span>
<span class="sd">        :type device: torch.device</span>
<span class="sd">        :param dtype: Floating point precision</span>
<span class="sd">        :type dtype: torch.dtype</span>
<span class="sd">        :raises ValueError: For unsupported kernel types or invalid vertex configurations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">init_vertices</span><span class="p">,</span> <span class="n">extended_vertices</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_cartesian</span><span class="p">(</span><span class="n">init_vertices</span><span class="p">)</span>
        <span class="n">extended</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_cartesian</span><span class="p">(</span><span class="n">extended_vertices</span><span class="p">)</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="n">extended</span> <span class="o">=</span> <span class="n">extended</span>

        <span class="n">dists</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rbf</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>

        <span class="n">dists_ext</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">extended</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">K_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rbf</span><span class="p">(</span><span class="n">dists_ext</span><span class="p">)</span>
        <span class="n">K_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">K_ext_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">K_ext</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">regularization</span> <span class="o">==</span> <span class="s2">&quot;spherical&quot;</span><span class="p">:</span>
            <span class="n">regularizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spherical_harmonic_regularization</span><span class="p">(</span><span class="n">init_vertices</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">regularization</span> <span class="o">==</span> <span class="s2">&quot;tikhonov&quot;</span><span class="p">:</span>
            <span class="n">regularizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">K_torch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently only spherical and tikhonov regularization is supported&quot;</span><span class="p">)</span>
        <span class="n">K_inv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">K_torch</span> <span class="o">+</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">regularizer</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;_transform_matrix&quot;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">K_inv</span><span class="p">,</span> <span class="n">K_ext_torch</span><span class="o">.</span><span class="n">mT</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_spherical_harmonic_regularization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">max_l</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use spherical harmonics as a smoother prior.&quot;&quot;&quot;</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="n">n_points</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">Y_lm</span> <span class="o">=</span> <span class="n">sph_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
                <span class="n">Y_col</span> <span class="o">=</span> <span class="n">Y_lm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">R</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Y_col</span> <span class="o">@</span> <span class="n">Y_col</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rbf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Radial basis functions.&quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">eps</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s2">&quot;multiquadric&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">eps</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s2">&quot;inverse_multiquadric&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">eps</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s2">&quot;cubic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s2">&quot;thin_plate&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="mf">1e-8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown kernel: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the matrix with the shape [N, M] which transforms initial function to extended function</span>
<span class="sd">        :return: transformation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_matrix</span>

<div class="viewcode-block" id="RBFInterpolator.forward">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.RBFInterpolator.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_values</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate values at extended points using RBF interpolation.</span>

<span class="sd">        :param f_values: Tensor of shape (..., N), where N = number of base vertices.</span>
<span class="sd">        :return: Interpolated values of shape (..., M), where M = number of extended vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">f_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_matrix</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="BarycentricInterpolator">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BarycentricInterpolator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BarycentricInterpolator</span><span class="p">(</span><span class="n">BaseInterpolator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spherical barycentric interpolator for data defined on a triangulated unit sphere.</span>

<span class="sd">    This class interpolates values from an initial spherical mesh to a new set of</span>
<span class="sd">    spherical points using true spherical barycentric coordinates.</span>

<span class="sd">    The interpolation process consists of:</span>
<span class="sd">        1. Converting spherical coordinates (phi, theta) to 3D Cartesian unit vectors.</span>
<span class="sd">        2. Finding, for each target point, the spherical triangle that contains it.</span>
<span class="sd">        3. Computing spherical barycentric coordinates using spherical triangle areas.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BarycentricInterpolator.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BarycentricInterpolator.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">init_vertices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">extended_vertices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">init_triangulation</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                 <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the spherical barycentric interpolator.</span>

<span class="sd">        :param init_vertices:</span>
<span class="sd">            Initial mesh vertices as (phi, theta) pairs in radians.</span>
<span class="sd">            Shape (N, 2), where phi ∈ [0, 2π), theta ∈ [0, π].</span>
<span class="sd">        :param extended_vertices:</span>
<span class="sd">            Target vertices for interpolation as (phi, theta) pairs.</span>
<span class="sd">            Shape (M, 2).</span>
<span class="sd">        :param init_triangulation:</span>
<span class="sd">            Triangle connectivity array of shape (T, 3), containing indices</span>
<span class="sd">            into `init_vertices`.</span>
<span class="sd">        :param device:</span>
<span class="sd">            PyTorch device on which the interpolation matrix is stored.</span>
<span class="sd">        :param dtype:</span>
<span class="sd">            Floating-point precision for interpolation weights.</span>
<span class="sd">        :param tol:</span>
<span class="sd">            Numerical tolerance used for spherical point-in-triangle tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">init_vertices</span><span class="p">,</span> <span class="n">extended_vertices</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extended_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_triangulation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_triangulation</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_cartesian</span><span class="p">(</span><span class="n">init_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_cartesian</span><span class="p">(</span><span class="n">extended_vertices</span><span class="p">)</span>

        <span class="n">tri_vertices_cart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_cartesian</span><span class="p">[</span><span class="n">init_triangulation</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tri_vertices_cart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orient_triangles</span><span class="p">(</span><span class="n">tri_vertices_cart</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;_transform_matrix&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_barycentric_weights</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_orient_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure consistent orientation of spherical triangles.</span>

<span class="sd">        Each triangle is oriented such that the great-circle normal of edge (a, b)</span>
<span class="sd">        satisfies:</span>
<span class="sd">            dot(a × b, c) &gt;= 0</span>

<span class="sd">        This guarantees consistent half-space tests during spherical</span>
<span class="sd">        point-in-triangle checks.</span>

<span class="sd">        :param triangles:</span>
<span class="sd">            Array of shape (T, 3, 3) containing Cartesian triangle vertices.</span>
<span class="sd">        :return:</span>
<span class="sd">            Array of shape (T, 3, 3) with consistently oriented triangles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">n_ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;i&quot;</span><span class="p">,</span> <span class="n">n_ab</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">flip_mask</span> <span class="o">=</span> <span class="n">check</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flip_mask</span><span class="p">):</span>
            <span class="n">triangles</span><span class="p">[</span><span class="n">flip_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">triangles</span><span class="p">[</span><span class="n">flip_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
                <span class="n">triangles</span><span class="p">[</span><span class="n">flip_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">triangles</span><span class="p">[</span><span class="n">flip_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">triangles</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_containing_triangles_spherical</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the containing spherical triangle for each target point.</span>

<span class="sd">        A point is considered inside a spherical triangle if it lies on the</span>
<span class="sd">        same side of all three great-circle edges. The test is performed</span>
<span class="sd">        using oriented edge normals and dot products.</span>

<span class="sd">        If a point is not found inside any triangle (due to numerical</span>
<span class="sd">        precision or boundary cases), a fallback selects the triangle whose</span>
<span class="sd">        centroid has the smallest angular distance to the point.</span>

<span class="sd">        :return:</span>
<span class="sd">            triangle_indices:</span>
<span class="sd">                Integer array of shape (M,) giving the triangle index</span>
<span class="sd">                associated with each target point.</span>
<span class="sd">            triangles:</span>
<span class="sd">                Array of shape (M, 3, 3) containing the Cartesian vertices</span>
<span class="sd">                of the selected triangles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_cartesian</span>
        <span class="n">TR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tri_vertices_cart</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">TR</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">TR</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">TR</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">TR</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">n_ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">n_bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">n_ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="n">n_ab</span> <span class="o">=</span> <span class="n">n_ab</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n_ab</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_bc</span> <span class="o">=</span> <span class="n">n_bc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n_bc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_ca</span> <span class="o">=</span> <span class="n">n_ca</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n_ca</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">P_bt</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;mij,tj-&gt;mt&#39;</span><span class="p">,</span> <span class="n">P_bt</span><span class="p">,</span> <span class="n">n_ab</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;mij,tj-&gt;mt&#39;</span><span class="p">,</span> <span class="n">P_bt</span><span class="p">,</span> <span class="n">n_bc</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;mij,tj-&gt;mt&#39;</span><span class="p">,</span> <span class="n">P_bt</span><span class="p">,</span> <span class="n">n_ca</span><span class="p">)</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>
        <span class="n">inside_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">d2</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">d3</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span><span class="p">)</span>  <span class="c1"># (M, T)</span>

        <span class="n">triangle_indices</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">found_any</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inside_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rows</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="n">tri_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inside_mask</span><span class="p">[</span><span class="n">m</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tri_candidates</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">triangle_indices</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">tri_candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">found_any</span><span class="p">):</span>
            <span class="n">not_found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">found_any</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">TR</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (T,3)</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="n">centroids</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dot_pc</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">not_found</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">centroids</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">dot_pc</span> <span class="o">=</span> <span class="n">dot_pc</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">nearest_tri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dot_pc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">triangle_indices</span><span class="p">[</span><span class="n">not_found</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_tri</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="n">TR</span><span class="p">[</span><span class="n">triangle_indices</span><span class="p">]</span>  <span class="c1"># (M,3,3)</span>
        <span class="k">return</span> <span class="n">triangle_indices</span><span class="p">,</span> <span class="n">triangles</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spherical_triangle_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the area of spherical triangles on the unit sphere.</span>

<span class="sd">        The area is computed using the numerically stable formula:</span>

<span class="sd">            area = 2 * atan2( |u · (v × w)|,</span>
<span class="sd">                              1 + u·v + v·w + w·u )</span>

<span class="sd">        All input vectors must be unit vectors.</span>

<span class="sd">        :param u:</span>
<span class="sd">            Array of shape (..., 3) representing the first vertex.</span>
<span class="sd">        :param v:</span>
<span class="sd">            Array of shape (..., 3) representing the second vertex.</span>
<span class="sd">        :param w:</span>
<span class="sd">            Array of shape (..., 3) representing the third vertex.</span>
<span class="sd">        :return:</span>
<span class="sd">            Array of spherical triangle areas with shape matching the</span>
<span class="sd">            broadcasted leading dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cross_vw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">cross_vw</span><span class="p">))</span>
        <span class="n">dot_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">dot_vw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">dot_wu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">dot_uv</span> <span class="o">+</span> <span class="n">dot_vw</span> <span class="o">+</span> <span class="n">dot_wu</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spherical_barycentric_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">triangles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute spherical barycentric coordinates for multiple points.</span>

<span class="sd">        For each point P and triangle (A, B, C), the barycentric weights are:</span>

<span class="sd">            w_A = area(P, B, C) / area(A, B, C)</span>
<span class="sd">            w_B = area(P, C, A) / area(A, B, C)</span>
<span class="sd">            w_C = area(P, A, B) / area(A, B, C)</span>

<span class="sd">        where all areas are spherical triangle areas.</span>

<span class="sd">        :param points:</span>
<span class="sd">            Array of shape (M, 3) containing Cartesian unit vectors</span>
<span class="sd">            of target points.</span>
<span class="sd">        :param triangles:</span>
<span class="sd">            Array of shape (M, 3, 3) containing Cartesian vertices</span>
<span class="sd">            of the associated triangles.</span>
<span class="sd">        :return:</span>
<span class="sd">            Array of shape (M, 3) containing barycentric weights</span>
<span class="sd">            corresponding to triangle vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">points</span>

        <span class="n">area_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spherical_triangle_area</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">area_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spherical_triangle_area</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">area_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spherical_triangle_area</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">total</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">+</span> <span class="n">area_c</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">total</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
        <span class="n">w_a</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">/</span> <span class="n">total</span>
        <span class="n">w_b</span> <span class="o">=</span> <span class="n">area_b</span> <span class="o">/</span> <span class="n">total</span>
        <span class="n">w_c</span> <span class="o">=</span> <span class="n">area_c</span> <span class="o">/</span> <span class="n">total</span>

        <span class="n">bary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">w_a</span><span class="p">,</span> <span class="n">w_b</span><span class="p">,</span> <span class="n">w_c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bary</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_barycentric_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Construct the interpolation weight matrix.</span>

<span class="sd">       The resulting matrix W satisfies:</span>

<span class="sd">           f_extended = f_init @ W</span>

<span class="sd">       where:</span>
<span class="sd">           f_init     has shape (..., N)</span>
<span class="sd">           W          has shape (N, M)</span>
<span class="sd">           f_extended has shape (..., M)</span>

<span class="sd">       The matrix is first assembled in sparse COO format and then</span>
<span class="sd">       converted to a dense tensor for efficient multiplication.</span>

<span class="sd">       :param device:</span>
<span class="sd">           PyTorch device on which the weight matrix is stored.</span>
<span class="sd">       :param dtype:</span>
<span class="sd">           Floating-point precision of the weights.</span>
<span class="sd">       :return:</span>
<span class="sd">           Dense PyTorch tensor of shape (N, M) containing interpolation weights.</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_vertices</span><span class="p">)</span>

        <span class="n">triangle_indices</span><span class="p">,</span> <span class="n">triangles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_containing_triangles_spherical</span><span class="p">()</span>
        <span class="n">bary_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spherical_barycentric_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_cartesian</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
        <span class="n">tri_vertex_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_triangulation</span><span class="p">[</span><span class="n">triangle_indices</span><span class="p">]</span>  <span class="c1"># (M,3)</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="n">tri_vertex_indices</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># (3M,)</span>
        <span class="n">col_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">bary_coords</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">row_indices_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">col_indices_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">col_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">values_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

        <span class="n">weight_matrix_sparse</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">row_indices_t</span><span class="p">,</span> <span class="n">col_indices_t</span><span class="p">]),</span>
            <span class="n">values_t</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">weight_matrix_sparse</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">weight_matrix</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the matrix with the shape [N, M] which transforms initial function to extended function</span>
<span class="sd">        :return: transformation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_matrix</span>

<div class="viewcode-block" id="BarycentricInterpolator.forward">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BarycentricInterpolator.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_values</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate values defined on the initial spherical mesh.</span>

<span class="sd">        :param f_values:</span>
<span class="sd">            Tensor of shape (..., N) containing values defined at the</span>
<span class="sd">            initial mesh vertices.</span>
<span class="sd">        :return:</span>
<span class="sd">            Tensor of shape (..., M) containing interpolated values</span>
<span class="sd">            at the target vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">f_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>
</div>



<div class="viewcode-block" id="MeshProcessorBase">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.MeshProcessorBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MeshProcessorBase</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for mesh processing pipelines with adaptive vertex generation.</span>

<span class="sd">    Generates spherical meshes with density increasing toward poles to maintain</span>
<span class="sd">    approximately uniform area per triangle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MeshProcessorBase.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.MeshProcessorBase.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">init_grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">boundaries_cond</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize mesh processor with geometric parameters.</span>

<span class="sd">       :param init_grid_frequency: Base resolution parameter controlling vertex count</span>
<span class="sd">       :type init_grid_frequency: int</span>
<span class="sd">       :param phi_limits: (phi_min, phi_max) bounds in radians</span>
<span class="sd">       :type phi_limits: tuple[float, float]</span>
<span class="sd">       :param boundaries_cond: Boundary handling: &quot;periodic&quot;, &quot;reflection&quot;, &quot;a&quot;, or None</span>
<span class="sd">       :type boundaries_cond: str | None</span>
<span class="sd">       :param device: Computation device</span>
<span class="sd">       :type device: torch.device</span>
<span class="sd">       :param dtype: Floating point precision</span>
<span class="sd">       :type dtype: torch.dtype</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_grid_frequency</span> <span class="o">=</span> <span class="n">init_grid_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span> <span class="o">=</span> <span class="n">phi_limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundaries_cond</span> <span class="o">=</span> <span class="n">boundaries_cond</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_point</span> <span class="o">=</span> <span class="n">boundaries_cond</span> <span class="o">!=</span> <span class="s2">&quot;periodic&quot;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_theta_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">last_point</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ThetaLine</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create theta lines with adaptive vertex density.</span>
<span class="sd">        Generates lines with increasing vertex count toward poles for uniform area.</span>

<span class="sd">        :param grid_frequency:</span>
<span class="sd">        :param last_point: Include or not the last point to computations. It is necessary to exclude the phi=2pi point.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="n">init_lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ThetaLine</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phi_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">,</span> <span class="n">last_point</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">ThetaLine</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">phi_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">,</span> <span class="n">last_point</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">ThetaLine</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">phi_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">,</span> <span class="n">last_point</span><span class="o">=</span><span class="n">last_point</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">init_lines</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">ThetaLine</span><span class="p">(</span>
                <span class="n">theta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid_frequency</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                <span class="n">points</span><span class="o">=</span><span class="n">point</span><span class="p">,</span>
                <span class="n">phi_limits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_limits</span><span class="p">,</span>
                <span class="n">last_point</span><span class="o">=</span><span class="n">last_point</span><span class="p">,</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">grid_frequency</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assemble_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ThetaLine</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate vertices from all theta lines into single array.</span>

<span class="sd">        :param theta_lines: List of ThetaLine objects</span>
<span class="sd">        :type theta_lines: list[ThetaLine]</span>
<span class="sd">        :return: Array of shape (N, 2) with [phi, theta] coordinates</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tl</span><span class="o">.</span><span class="n">phi_theta</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">tl</span> <span class="ow">in</span> <span class="n">theta_lines</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_lines</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">ThetaLine</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate triangle connectivity for a spherical mesh with adaptive phi sampling.</span>

<span class="sd">        Handles variable numbers of vertices per theta line and correctly enforces periodic</span>
<span class="sd">        boundary conditions in the azimuthal (phi) direction. When a `ThetaLine` has</span>
<span class="sd">        `last_point=False`, its logical endpoint at φ = 2π is not stored as a separate vertex;</span>
<span class="sd">        instead, it is identified with the first vertex of the same line (φ = 0).</span>

<span class="sd">        As a result:</span>
<span class="sd">        - If `last_point=True`, all `latent_points` are stored as distinct vertices.</span>
<span class="sd">        - If `last_point=False`, only `latent_points - 1` vertices are stored, and any reference</span>
<span class="sd">          to the missing φ = 2π point during triangle construction maps to the first vertex</span>
<span class="sd">          of that theta line.</span>

<span class="sd">        The total number of triangles remains unchanged compared to a fully sampled mesh;</span>
<span class="sd">        only vertex indices are adjusted to reflect the wrapping.</span>

<span class="sd">        Example 1 (all lines include φ = 2π):</span>
<span class="sd">            ThetaLines (4 total, all `last_point=True`) yield vertices:</span>
<span class="sd">                Line 0: [v0]</span>
<span class="sd">                Line 1: [v1, v2]</span>
<span class="sd">                Line 2: [v3, v4, v5]</span>
<span class="sd">                Line 3: [v6, v7, v8, v9]</span>
<span class="sd">            Triangles include: [2, 4, 5], etc.</span>

<span class="sd">        Example 2 (last two lines exclude φ = 2π):</span>
<span class="sd">            Same logical structure, but stored vertices:</span>
<span class="sd">                Line 0: [v0]</span>
<span class="sd">                Line 1: [v1, v2]</span>
<span class="sd">                Line 2: [v3, v4]          # latent=3 → stores 2 points</span>
<span class="sd">                Line 3: [v5, v6, v7]      # latent=4 → stores 3 points</span>
<span class="sd">            Triangle [2, 4, 3] appears because the logical point at φ=2π on line 2</span>
<span class="sd">            wraps to index 3 (its first vertex).</span>

<span class="sd">        :param theta_lines: List of `ThetaLine` objects defining the mesh rows.</span>
<span class="sd">                            The first two lines must have `last_point=True` to anchor the poles.</span>
<span class="sd">        :type theta_lines: list[ThetaLine]</span>
<span class="sd">        :return: Array of shape `(M, 3)` containing vertex indices for each triangle.</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">)</span>

        <span class="n">n_actual</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">_compute_visible_points</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">theta_lines</span><span class="p">]</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_actual</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">idx</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">%</span> <span class="n">n_actual</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">if</span> <span class="n">n_actual</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">upward</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">latent_points</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)})</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="p">]</span>

        <span class="n">downward</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">theta_lines</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">latent_points</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">idx</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">)})</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upward</span> <span class="o">+</span> <span class="n">downward</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_triangulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_lines</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">ThetaLine</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate triangle connectivity for given grid resolution.</span>

<span class="sd">        :param theta_lines: List of `ThetaLine` objects defining the mesh rows.</span>
<span class="sd">                            The first two lines must have `last_point=True` to anchor the poles.</span>
<span class="sd">        :type theta_lines: list[ThetaLine]</span>
<span class="sd">        :return: Triangle connectivity array</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_triangles</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">)</span></div>



<div class="viewcode-block" id="InterpolatorsName">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.InterpolatorsName">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InterpolatorsName</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration of supported interpolator types.&quot;&quot;&quot;</span>
    <span class="n">RBF</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rbf&quot;</span>
    <span class="n">BARYCENTRIC</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;barycentric&quot;</span></div>



<div class="viewcode-block" id="InterpolatingMeshProcessor">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.InterpolatingMeshProcessor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InterpolatingMeshProcessor</span><span class="p">(</span><span class="n">MeshProcessorBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mesh processor with interpolation from coarse to fine grid.</span>

<span class="sd">    Uses nearest-neighbor interpolation to transfer function values from</span>
<span class="sd">    initial mesh to higher-resolution target mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InterpolatingMeshProcessor.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.InterpolatingMeshProcessor.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">interpolate_grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">init_grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">boundaries_cond</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">interpolator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolatorsName</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">BaseInterpolator</span><span class="p">]],</span>
                 <span class="n">interpolator_kwargs</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]],</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize interpolating mesh processor.</span>

<span class="sd">       :param interpolate_grid_frequency: Target resolution for interpolation</span>
<span class="sd">       :type interpolate_grid_frequency: int</span>
<span class="sd">       :param init_grid_frequency: Base resolution for initial mesh</span>
<span class="sd">       :type init_grid_frequency: int</span>
<span class="sd">       :param phi_limits: (phi_min, phi_max) bounds</span>
<span class="sd">       :type phi_limits: tuple[float, float]</span>
<span class="sd">       :param boundaries_cond: Boundary condition type</span>
<span class="sd">       :type boundaries_cond: str | None</span>

<span class="sd">       :param interpolator: Interpolator type or custom class</span>
<span class="sd">       :type interpolator: tp.Union[InterpolatorsName, type[BaseInterpolator]]</span>
<span class="sd">       :param interpolator_kwargs: Configuration for interpolator constructor</span>
<span class="sd">       :type interpolator_kwargs: tp.Union[dict[str, Any], None]</span>

<span class="sd">       :param device: Computation device</span>
<span class="sd">       :type device: torch.device</span>
<span class="sd">       :param dtype: Floating point precision</span>
<span class="sd">       :type dtype: torch.dtype</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">init_grid_frequency</span><span class="o">=</span><span class="n">init_grid_frequency</span><span class="p">,</span>
            <span class="n">phi_limits</span><span class="o">=</span><span class="n">phi_limits</span><span class="p">,</span>
            <span class="n">boundaries_cond</span><span class="o">=</span><span class="n">boundaries_cond</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_grid_frequency</span> <span class="o">=</span> <span class="n">interpolate_grid_frequency</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_theta_lines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_grid_frequency</span><span class="p">,</span> <span class="n">last_point</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolating_theta_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_theta_lines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolate_grid_frequency</span><span class="p">,</span> <span class="n">last_point</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_post_mesh</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interpolator</span><span class="p">(</span><span class="n">interpolator</span><span class="p">,</span> <span class="n">interpolator_kwargs</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extended_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_post_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate vertices and triangles for target resolution mesh.</span>

<span class="sd">       :return: Tuple of (vertices, triangles)</span>
<span class="sd">       :rtype: tuple[np.ndarray, np.ndarray]</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="n">extended_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolating_theta_lines</span><span class="p">)</span>
        <span class="n">simplices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_triangulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolating_theta_lines</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extended_vertices</span><span class="p">,</span> <span class="n">simplices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">interpolator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolatorsName</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">BaseInterpolator</span><span class="p">]],</span>
                          <span class="n">interpolator_kwargs</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]],</span>
                          <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseInterpolator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate interpolator based on specification.</span>

<span class="sd">        :param interpolator: Enum value or BaseInterpolator subclass</span>
<span class="sd">        :type interpolator: InterpolatorsName | type[BaseInterpolator]</span>
<span class="sd">        :param interpolator_kwargs: Configuration parameters for constructor</span>
<span class="sd">        :type interpolator_kwargs: dict[str, Any] | None</span>
<span class="sd">        :param device: Computation device</span>
<span class="sd">        :type device: torch.device</span>
<span class="sd">        :param dtype: Floating point precision</span>
<span class="sd">        :return: Instantiated interpolator object</span>
<span class="sd">        :rtype: BaseInterpolator</span>
<span class="sd">        :raises NotImplementedError: For unsupported interpolator types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interpolator_kwargs</span> <span class="o">=</span> <span class="n">interpolator_kwargs</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">interpolator</span> <span class="o">==</span> <span class="n">InterpolatorsName</span><span class="o">.</span><span class="n">RBF</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RBFInterpolator</span><span class="p">(</span><span class="n">init_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span><span class="p">,</span>
                                   <span class="n">extended_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="p">,</span>
                                   <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">interpolator_kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">interpolator</span> <span class="o">==</span> <span class="n">InterpolatorsName</span><span class="o">.</span><span class="n">BARYCENTRIC</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BarycentricInterpolator</span><span class="p">(</span>
                <span class="n">init_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span><span class="p">,</span>
                <span class="n">extended_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="p">,</span>
                <span class="n">init_triangulation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_triangles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span><span class="p">),</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">interpolator_kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">interpolator</span><span class="p">,</span> <span class="n">BaseInterpolator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span>
                <span class="n">init_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span><span class="p">,</span>
                <span class="n">extended_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">interpolator_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The interpolator can be only rbf and baricentric or custom class&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="InterpolatingMeshProcessor.forward">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.InterpolatingMeshProcessor.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_values</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate function values to higher resolution mesh.</span>

<span class="sd">        :param f_values: Function values at base vertices, shape (..., N)</span>
<span class="sd">        :type f_values: torch.Tensor</span>
<span class="sd">        :return: Interpolated values at extended vertices, shape (..., M)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">f_values</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">init_vert_dim</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">f_new</span> <span class="o">=</span> <span class="n">f_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">init_vert_dim</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="p">(</span><span class="n">f_new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span></div>
</div>



<div class="viewcode-block" id="BoundaryMeshProcessor">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BoundaryMeshProcessor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BoundaryMeshProcessor</span><span class="p">(</span><span class="n">MeshProcessorBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mesh processor with boundary condition handling but no interpolation.</span>

<span class="sd">    Used when mesh resolution remains constant but boundary conditions require</span>
<span class="sd">    special vertex handling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BoundaryMeshProcessor.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BoundaryMeshProcessor.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">init_grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">boundaries_cond</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize boundary-aware mesh processor.</span>

<span class="sd">        :param init_grid_frequency: Base mesh resolution</span>
<span class="sd">        :type init_grid_frequency: int</span>
<span class="sd">        :param phi_limits: Azimuthal bounds (phi_min, phi_max)</span>
<span class="sd">        :type phi_limits: tuple[float, float]</span>
<span class="sd">        :param boundaries_cond: Boundary condition type</span>
<span class="sd">        :type boundaries_cond: str | None</span>
<span class="sd">        :param device: Computation device</span>
<span class="sd">        :type device: torch.device</span>
<span class="sd">        :param dtype: Floating point precision</span>
<span class="sd">        :type dtype: torch.dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">init_grid_frequency</span><span class="o">=</span><span class="n">init_grid_frequency</span><span class="p">,</span>
            <span class="n">phi_limits</span><span class="o">=</span><span class="n">phi_limits</span><span class="p">,</span>
            <span class="n">boundaries_cond</span><span class="o">=</span><span class="n">boundaries_cond</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_theta_lines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_grid_frequency</span><span class="p">,</span> <span class="n">last_point</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_post_mesh</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_post_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate vertices and triangles for target resolution mesh.</span>

<span class="sd">        :return: Tuple of (vertices, triangles)</span>
<span class="sd">        :rtype: tuple[np.ndarray, np.ndarray]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assemble_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span><span class="p">)</span>
        <span class="n">simplices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_triangulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_theta_lines</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">simplices</span>

<div class="viewcode-block" id="BoundaryMeshProcessor.forward">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.BoundaryMeshProcessor.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_values</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass through function values unchanged (no interpolation).</span>

<span class="sd">        :param f_values: Function values at mesh vertices</span>
<span class="sd">        :type f_values: torch.Tensor</span>
<span class="sd">        :return: Same values (identity operation)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">f_values</span></div>
</div>



<div class="viewcode-block" id="mesh_processor_factory">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.mesh_processor_factory">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mesh_processor_factory</span><span class="p">(</span><span class="n">init_grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">interpolate_grid_frequency</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                           <span class="n">interpolate</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                           <span class="n">interpolator</span><span class="p">:</span> <span class="n">InterpolatorsName</span><span class="p">,</span>
                           <span class="n">interpolator_kwargs</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]],</span>
                           <span class="n">boundaries_cond</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                           <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                           <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">InterpolatingMeshProcessor</span><span class="p">,</span> <span class="n">BoundaryMeshProcessor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory function for creating appropriate mesh processor instance.</span>

<span class="sd">    Selects processor type based on interpolation requirements and boundary conditions.</span>

<span class="sd">    :param init_grid_frequency: Base mesh resolution</span>
<span class="sd">    :type init_grid_frequency: int</span>
<span class="sd">    :param interpolate_grid_frequency: Target resolution for interpolation</span>
<span class="sd">    :type interpolate_grid_frequency: int</span>
<span class="sd">    :param interpolate: Whether to perform mesh refinement interpolation</span>
<span class="sd">    :type interpolate: bool</span>
<span class="sd">    :param boundaries_cond: Boundary condition type</span>
<span class="sd">    :type boundaries_cond: str | None</span>

<span class="sd">    :param interpolator: Enum value or BaseInterpolator subclass</span>
<span class="sd">    :type interpolator: InterpolatorsName | type[BaseInterpolator]</span>
<span class="sd">    :param interpolator_kwargs: Configuration parameters for constructor</span>
<span class="sd">    :type interpolator_kwargs: dict[str, Any] | None</span>

<span class="sd">    :param phi_limits: (phi_min, phi_max) bounds</span>
<span class="sd">    :type phi_limits: tuple[float, float]</span>
<span class="sd">    :param device: Computation device</span>
<span class="sd">    :type device: torch.device</span>
<span class="sd">    :param dtype: Floating point precision</span>
<span class="sd">    :type dtype: torch.dtype</span>
<span class="sd">    :return: Configured mesh processor instance</span>
<span class="sd">    :rtype: tp.Union[InterpolatingMeshProcessor, BoundaryMeshProcessor]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">InterpolatingMeshProcessor</span><span class="p">(</span>
            <span class="n">interpolate_grid_frequency</span><span class="o">=</span><span class="n">interpolate_grid_frequency</span><span class="p">,</span>
            <span class="n">init_grid_frequency</span><span class="o">=</span><span class="n">init_grid_frequency</span><span class="p">,</span>
            <span class="n">phi_limits</span><span class="o">=</span><span class="n">phi_limits</span><span class="p">,</span>
            <span class="n">boundaries_cond</span><span class="o">=</span><span class="n">boundaries_cond</span><span class="p">,</span> <span class="n">interpolator</span><span class="o">=</span><span class="n">interpolator</span><span class="p">,</span>
            <span class="n">interpolator_kwargs</span><span class="o">=</span><span class="n">interpolator_kwargs</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">boundaries_cond</span> <span class="o">!=</span> <span class="s2">&quot;periodic&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BoundaryMeshProcessor</span><span class="p">(</span>
            <span class="n">init_grid_frequency</span><span class="o">=</span><span class="n">init_grid_frequency</span><span class="p">,</span>
            <span class="n">phi_limits</span><span class="o">=</span><span class="n">phi_limits</span><span class="p">,</span>
            <span class="n">boundaries_cond</span><span class="o">=</span><span class="n">boundaries_cond</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify either interpolation or non-periodic boundaries&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="DelaunayMesh">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMesh">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaunayMesh</span><span class="p">(</span><span class="n">BaseMeshPowder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Delaunay triangulation-based spherical mesh for powder averaging.</span>

<span class="sd">    Generates adaptive-resolution meshes with optional interpolation for</span>
<span class="sd">    efficient powder averaging in magnetic resonance simulations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelaunayMesh.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMesh.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
                 <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
                 <span class="n">initial_grid_frequency</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                 <span class="n">interpolation_grid_frequency</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
                 <span class="n">boundaries_cond</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">interpolator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">InterpolatorsName</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">BaseInterpolator</span><span class="p">]]</span> <span class="o">=</span> <span class="n">InterpolatorsName</span><span class="o">.</span><span class="n">RBF</span><span class="p">,</span>
                 <span class="n">interpolator_kwargs</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Delaunay mesh with geometric and processing parameters.</span>

<span class="sd">        :param eps: Small value for numerical stability near poles</span>
<span class="sd">        :type eps: float</span>
<span class="sd">        :param phi_limits: (phi_min, phi_max) bounds in radians</span>
<span class="sd">        :type phi_limits: tuple[float, float]</span>
<span class="sd">        :param initial_grid_frequency: Base resolution parameter</span>
<span class="sd">        :type initial_grid_frequency: int</span>
<span class="sd">        :param interpolation_grid_frequency: Target resolution when interpolating</span>
<span class="sd">        :type interpolation_grid_frequency: int</span>
<span class="sd">        :param boundaries_cond: Doesn&#39;t support yet</span>
<span class="sd">        :type boundaries_cond: tp.Optional[str, None]</span>
<span class="sd">        :param interpolate: Whether to interpolate to higher resolution mesh</span>

<span class="sd">        :type interpolate: bool</span>
<span class="sd">        :param interpolator: The Interpolation method.</span>
<span class="sd">        Currently it supports rbf, barycentric interpolation or custom interpolator</span>
<span class="sd">        :type interpolator: tp.Union[str, InterpolatorsName, tp.Type[BaseInterpolator]]</span>

<span class="sd">        :param interpolator_kwargs: Optional keyword arguments passed to the interpolator constructor.</span>
<span class="sd">        These may include parameters such as ``jitter``, ``regularization``, ``kernel``, ``tol``, etc.,</span>
<span class="sd">        depending on the specific interpolator type.</span>

<span class="sd">        For a complete list of supported options, refer to the documentation of:</span>
<span class="sd">        - :class:`mars.mesher.delaunay_neighbour.RBFInterpolator`</span>
<span class="sd">        - :class:`mars.mesher.delaunay_neighbour.BarycentricInterpolator`</span>

<span class="sd">        :param device: Computation device</span>
<span class="sd">        :type device: torch.device</span>
<span class="sd">        :param dtype: Floating point precision</span>
<span class="sd">        :type dtype: torch.dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_limit</span> <span class="o">=</span> <span class="n">phi_limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_grid_frequency</span> <span class="o">=</span> <span class="n">initial_grid_frequency</span>
        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_grid_frequency</span> <span class="o">=</span> <span class="n">interpolation_grid_frequency</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_grid_frequency</span> <span class="o">=</span> <span class="n">initial_grid_frequency</span>

        <span class="k">if</span> <span class="n">boundaries_cond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Boundaries condition is not supported in this version&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_processor</span> <span class="o">=</span> <span class="n">mesh_processor_factory</span><span class="p">(</span><span class="n">initial_grid_frequency</span><span class="p">,</span> <span class="n">interpolation_grid_frequency</span><span class="p">,</span>
                                                     <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span>
                                                     <span class="n">interpolator</span><span class="o">=</span><span class="n">interpolator</span><span class="p">,</span>
                                                     <span class="n">interpolator_kwargs</span><span class="o">=</span><span class="n">interpolator_kwargs</span><span class="p">,</span>
                                                     <span class="n">boundaries_cond</span><span class="o">=</span><span class="n">boundaries_cond</span><span class="p">,</span>
                                                     <span class="n">phi_limits</span><span class="o">=</span><span class="n">phi_limits</span><span class="p">,</span>
                                                     <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="p">(</span><span class="n">initial_grid</span><span class="p">,</span>
         <span class="n">post_grid</span><span class="p">,</span>
         <span class="n">post_simplices</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_initial_cache_data</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;_initial_grid&quot;</span><span class="p">,</span> <span class="n">initial_grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;_post_grid&quot;</span><span class="p">,</span> <span class="n">post_grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;_post_simplices&quot;</span><span class="p">,</span> <span class="n">post_simplices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></div>


<div class="viewcode-block" id="DelaunayMesh.create_initial_cache_data">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMesh.create_initial_cache_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_initial_cache_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Precompute and cache mesh geometry data on specified device.</span>

<span class="sd">        :param device: Target computation device</span>
<span class="sd">        :type device: torch.device</span>
<span class="sd">        :return: Tuple of (initial_vertices, final_vertices, simplices)</span>
<span class="sd">        :rtype: tuple[torch.Tensor, torch.Tensor, torch.Tensor]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_processor</span><span class="o">.</span><span class="n">init_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_processor</span><span class="o">.</span><span class="n">final_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_processor</span><span class="o">.</span><span class="n">simplices</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">post_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Processed mesh geometry after interpolation/boundary handling.</span>

<span class="sd">        :return: Tuple of (vertices, triangles) with vertices shape (N, 2),</span>
<span class="sd">            triangles shape (M, 3)</span>
<span class="sd">        :rtype: tuple[torch.Tensor, torch.Tensor]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_simplices</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">initial_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial coarse mesh vertices before processing.</span>

<span class="sd">        :return: Tensor of shape (N, 2) with [phi, theta] coordinates</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_grid</span>

<div class="viewcode-block" id="DelaunayMesh.to_delaunay">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMesh.to_delaunay">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_delaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">f_post</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                    <span class="n">simplices</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format function values per simplex for Delaunay rendering.</span>

<span class="sd">        :param f_post: Function values at mesh vertices, shape (..., N)</span>
<span class="sd">        :type f_post: torch.Tensor</span>
<span class="sd">        :param simplices: Triangle connectivity indices, shape (M, 3)</span>
<span class="sd">        :type simplices: torch.Tensor</span>
<span class="sd">        :return: Values arranged per simplex, shape (..., M, 3)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">f_post</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">simplices</span><span class="p">]</span></div>


<div class="viewcode-block" id="DelaunayMesh.forward">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMesh.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">f_init</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process function values through mesh pipeline (interpolation/boundaries).</span>

<span class="sd">        :param f_init: Function values at initial mesh vertices, shape (..., N)</span>
<span class="sd">        :type f_init: torch.Tensor</span>
<span class="sd">        :return: Processed values at final mesh vertices, shape (..., M)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_processor</span><span class="p">(</span><span class="n">f_init</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DelaunayMeshFullSphere">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMeshFullSphere">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaunayMeshFullSphere</span><span class="p">(</span><span class="n">DelaunayMesh</span><span class="p">):</span>
<div class="viewcode-block" id="DelaunayMeshFullSphere.__init__">
<a class="viewcode-back" href="../../../api/mars.mesher.html#mars.mesher.delanay_neighbour.DelaunayMeshFullSphere.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span>
                 <span class="n">phi_limits</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
                 <span class="n">initial_grid_frequency</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                 <span class="n">interpolation_grid_frequency</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
                 <span class="n">boundaries_cond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">phi_limits</span><span class="p">,</span> <span class="n">initial_grid_frequency</span><span class="p">,</span>
                         <span class="n">interpolation_grid_frequency</span><span class="p">,</span> <span class="n">boundaries_cond</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span>
                         <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
                         <span class="p">)</span>
        <span class="n">_second_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_grid</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="n">_second_unit</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">_second_unit</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_grid</span><span class="p">,</span> <span class="n">_second_unit</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">_second_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_grid</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">_second_unit</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">_second_unit</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_post_grid</span><span class="p">,</span> <span class="n">_second_unit</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">second_simpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_simplices</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">second_simpl</span> <span class="o">=</span> <span class="n">second_simpl</span> <span class="o">+</span> <span class="n">_second_unit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_simplices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_post_simplices</span><span class="p">,</span> <span class="n">second_simpl</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Arkady Samsonenko, Ivan Kurgansky.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>